# -*- coding: utf-8 -*-
"""TimesNet_strealit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WTBsAxUjO-nDfBh1sAwQ-ekm4UQzxXfk
"""

def get_model_prediction(stock_code, current_hour_key):
    # current_hour_key 이전 16개 데이터 가져오기
    cursor.execute('SELECT * FROM price_info WHERE stock_code = ? AND time_key < ? ORDER BY time_key DESC LIMIT ?', (stock_code, current_hour_key, 16))
    rows = cursor.fetchall()

    if len(rows) < 16:
        return None  # 데이터가 충분하지 않으면 None 반환

    # 데이터를 DataFrame으로 변환
    df = pd.DataFrame(rows, columns=['Datetime', 'stock_code', 'High', 'Low', 'Open', 'Close', 'Volume'])

    # 데이터 전처리
    data = df.reset_index(drop=True)
    data = data.rename(columns={"Datetime": "ds", "Close": "y"})
    data['unique_id'] = stock_code
    data['ds'] = np.arange(len(data))

    # Feature 조합
    data['O-C'] = data['Open'] - data['y']
    data['H-L'] = data['High'] - data['Low']
    data['2Hr_MA'] = data['y'].rolling(window=2).mean()
    data['4Hr_MA'] = data['y'].rolling(window=4).mean()
    data['6Hr_MA'] = data['y'].rolling(window=6).mean()
    data['3Hr_Std'] = data['y'].rolling(window=3).std()
    data['FastSO_6'] = ((data['y'] - data['Low'].rolling(window=6).min()) /
                        (data['High'].rolling(window=6).max() - data['Low'].rolling(window=6).min())) * 100

    # CCI
    def cci(data, window=6):
        typical_price = (data['High'] + data['Low'] + data['y']) / 3
        sma = typical_price.rolling(window=window).mean()
        mean_deviation = abs(typical_price - sma).rolling(window=window).mean()
        cci = (typical_price - sma) / (0.015 * mean_deviation)
        return cci

    data['CCI_6'] = cci(data, window=6)

    # 데이터셋 나누기
    data = data[['ds', 'y', 'unique_id', 'O-C', '2Hr_MA', 'H-L', 'FastSO_6', 'CCI_6', '4Hr_MA', '6Hr_MA']]
    f_data = data.iloc[[-1]]
    f_data['ds'] = f_data['ds'] + 1

    # 모델 생성
    horizon = 1
    models = [TimesNet(
                h=horizon,
                input_size=12,
                max_steps=40,
                top_k=4,
                num_kernels=3,
                futr_exog_list=['O-C', '2Hr_MA', 'H-L', 'FastSO_6', 'CCI_6', '4Hr_MA', '6Hr_MA'],
                exclude_insample_y=False,
                hidden_size=64,
                dropout=0.1,
                conv_hidden_size=64,
                encoder_layers=2,
                loss=MAE(),
                valid_loss=None,
                learning_rate=1e-4,
                num_lr_decays=-1,
                early_stop_patience_steps=-1,
                val_check_steps=100,
                batch_size=32,
                valid_batch_size=None,
                windows_batch_size=64,
                inference_windows_batch_size=256,
                start_padding_enabled=False,
                scaler_type='minmax',
                random_seed=1,
                num_workers_loader=0,
                drop_last_loader=False,
                optimizer=None
            )]

    nf = NeuralForecast(models=models, freq=1, local_scaler_type='robust')
    nf.fit(df=data)

    Y_hat_df = nf.predict(futr_df=f_data)
    Y_hat_df = Y_hat_df.reset_index(drop=False)
    predicted = Y_hat_df['TimesNet'][0]

    # predicted -> 예측값
    return predicted